\hypertarget{base58_8h}{}\section{/\+Users/christopherarguello/\+Developer/anon/src/base58.h File Reference}
\label{base58_8h}\index{/\+Users/christopherarguello/\+Developer/anon/src/base58.\+h@{/\+Users/christopherarguello/\+Developer/anon/src/base58.\+h}}
{\ttfamily \#include \char`\"{}chainparams.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}key.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}pubkey.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}script/script.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}script/standard.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}support/allocators/zeroafterfree.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}zcash/\+Address.\+hpp\char`\"{}}\newline
{\ttfamily \#include $<$string$>$}\newline
{\ttfamily \#include $<$vector$>$}\newline
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{class_c_base58_data}{C\+Base58\+Data}}
\item 
class \mbox{\hyperlink{class_c_z_c_payment_address}{C\+Z\+C\+Payment\+Address}}
\item 
class \mbox{\hyperlink{class_c_z_c_spending_key}{C\+Z\+C\+Spending\+Key}}
\item 
class \mbox{\hyperlink{class_c_bitcoin_address}{C\+Bitcoin\+Address}}
\item 
class \mbox{\hyperlink{class_c_bitcoin_secret}{C\+Bitcoin\+Secret}}
\item 
class \mbox{\hyperlink{class_c_bitcoin_ext_key_base}{C\+Bitcoin\+Ext\+Key\+Base$<$ K, Size, Type $>$}}
\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef \mbox{\hyperlink{class_c_bitcoin_ext_key_base}{C\+Bitcoin\+Ext\+Key\+Base}}$<$ \mbox{\hyperlink{struct_c_ext_key}{C\+Ext\+Key}}, 74, \mbox{\hyperlink{class_c_chain_params_aa294058ec2e3586bd8d03d6c39667058ab5636e60152f35f6595fe413eae430b0}{C\+Chain\+Params\+::\+E\+X\+T\+\_\+\+S\+E\+C\+R\+E\+T\+\_\+\+K\+EY}} $>$ \mbox{\hyperlink{base58_8h_a34d676ba7e9ada0b90c49397b7d7b45a}{C\+Bitcoin\+Ext\+Key}}
\item 
typedef \mbox{\hyperlink{class_c_bitcoin_ext_key_base}{C\+Bitcoin\+Ext\+Key\+Base}}$<$ \mbox{\hyperlink{struct_c_ext_pub_key}{C\+Ext\+Pub\+Key}}, 74, \mbox{\hyperlink{class_c_chain_params_aa294058ec2e3586bd8d03d6c39667058a1259eb07831c689e393e5008d7bd0085}{C\+Chain\+Params\+::\+E\+X\+T\+\_\+\+P\+U\+B\+L\+I\+C\+\_\+\+K\+EY}} $>$ \mbox{\hyperlink{base58_8h_a30ba109360a623ffbb1e1031c3765c10}{C\+Bitcoin\+Ext\+Pub\+Key}}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
std\+::string \mbox{\hyperlink{base58_8h_a8d6f0e9d5df175b4966dcede31dc90ad}{Encode\+Base58}} (const unsigned char $\ast$pbegin, const unsigned char $\ast$pend)
\item 
std\+::string \mbox{\hyperlink{base58_8h_ab95cf95fa4e2631017335c2ea73090bc}{Encode\+Base58}} (const std\+::vector$<$ unsigned char $>$ \&vch)
\item 
bool \mbox{\hyperlink{base58_8h_a2a7a6efa38bda9181b9a28ab3e675bea}{Decode\+Base58}} (const char $\ast$psz, std\+::vector$<$ unsigned char $>$ \&vch\+Ret)
\item 
bool \mbox{\hyperlink{base58_8h_a83e290bb1b09e9c26a86863c5641111f}{Decode\+Base58}} (const std\+::string \&str, std\+::vector$<$ unsigned char $>$ \&vch\+Ret)
\item 
std\+::string \mbox{\hyperlink{base58_8h_ace9a5807ee51604f33044339f073ec76}{Encode\+Base58\+Check}} (const std\+::vector$<$ unsigned char $>$ \&vch\+In)
\item 
bool \mbox{\hyperlink{base58_8h_ae2dc7ad63e243509e0871ec4a5890678}{Decode\+Base58\+Check}} (const char $\ast$psz, std\+::vector$<$ unsigned char $>$ \&vch\+Ret)
\item 
bool \mbox{\hyperlink{base58_8h_a96597527b13547236b99430e6ac195b3}{Decode\+Base58\+Check}} (const std\+::string \&str, std\+::vector$<$ unsigned char $>$ \&vch\+Ret)
\end{DoxyCompactItemize}


\subsection{Typedef Documentation}
\mbox{\Hypertarget{base58_8h_a34d676ba7e9ada0b90c49397b7d7b45a}\label{base58_8h_a34d676ba7e9ada0b90c49397b7d7b45a}} 
\index{base58.\+h@{base58.\+h}!C\+Bitcoin\+Ext\+Key@{C\+Bitcoin\+Ext\+Key}}
\index{C\+Bitcoin\+Ext\+Key@{C\+Bitcoin\+Ext\+Key}!base58.\+h@{base58.\+h}}
\subsubsection{\texorpdfstring{C\+Bitcoin\+Ext\+Key}{CBitcoinExtKey}}
{\footnotesize\ttfamily typedef \mbox{\hyperlink{class_c_bitcoin_ext_key_base}{C\+Bitcoin\+Ext\+Key\+Base}}$<$\mbox{\hyperlink{struct_c_ext_key}{C\+Ext\+Key}}, 74, \mbox{\hyperlink{class_c_chain_params_aa294058ec2e3586bd8d03d6c39667058ab5636e60152f35f6595fe413eae430b0}{C\+Chain\+Params\+::\+E\+X\+T\+\_\+\+S\+E\+C\+R\+E\+T\+\_\+\+K\+EY}}$>$ \mbox{\hyperlink{base58_8h_a34d676ba7e9ada0b90c49397b7d7b45a}{C\+Bitcoin\+Ext\+Key}}}

\mbox{\Hypertarget{base58_8h_a30ba109360a623ffbb1e1031c3765c10}\label{base58_8h_a30ba109360a623ffbb1e1031c3765c10}} 
\index{base58.\+h@{base58.\+h}!C\+Bitcoin\+Ext\+Pub\+Key@{C\+Bitcoin\+Ext\+Pub\+Key}}
\index{C\+Bitcoin\+Ext\+Pub\+Key@{C\+Bitcoin\+Ext\+Pub\+Key}!base58.\+h@{base58.\+h}}
\subsubsection{\texorpdfstring{C\+Bitcoin\+Ext\+Pub\+Key}{CBitcoinExtPubKey}}
{\footnotesize\ttfamily typedef \mbox{\hyperlink{class_c_bitcoin_ext_key_base}{C\+Bitcoin\+Ext\+Key\+Base}}$<$\mbox{\hyperlink{struct_c_ext_pub_key}{C\+Ext\+Pub\+Key}}, 74, \mbox{\hyperlink{class_c_chain_params_aa294058ec2e3586bd8d03d6c39667058a1259eb07831c689e393e5008d7bd0085}{C\+Chain\+Params\+::\+E\+X\+T\+\_\+\+P\+U\+B\+L\+I\+C\+\_\+\+K\+EY}}$>$ \mbox{\hyperlink{base58_8h_a30ba109360a623ffbb1e1031c3765c10}{C\+Bitcoin\+Ext\+Pub\+Key}}}



\subsection{Function Documentation}
\mbox{\Hypertarget{base58_8h_a2a7a6efa38bda9181b9a28ab3e675bea}\label{base58_8h_a2a7a6efa38bda9181b9a28ab3e675bea}} 
\index{base58.\+h@{base58.\+h}!Decode\+Base58@{Decode\+Base58}}
\index{Decode\+Base58@{Decode\+Base58}!base58.\+h@{base58.\+h}}
\subsubsection{\texorpdfstring{Decode\+Base58()}{DecodeBase58()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily bool Decode\+Base58 (\begin{DoxyParamCaption}\item[{const char $\ast$}]{psz,  }\item[{std\+::vector$<$ unsigned char $>$ \&}]{vch\+Ret }\end{DoxyParamCaption})}

Decode a base58-\/encoded string (psz) into a byte vector (vch\+Ret). return true if decoding is successful. psz cannot be N\+U\+LL. \mbox{\Hypertarget{base58_8h_a83e290bb1b09e9c26a86863c5641111f}\label{base58_8h_a83e290bb1b09e9c26a86863c5641111f}} 
\index{base58.\+h@{base58.\+h}!Decode\+Base58@{Decode\+Base58}}
\index{Decode\+Base58@{Decode\+Base58}!base58.\+h@{base58.\+h}}
\subsubsection{\texorpdfstring{Decode\+Base58()}{DecodeBase58()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily bool Decode\+Base58 (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{str,  }\item[{std\+::vector$<$ unsigned char $>$ \&}]{vch\+Ret }\end{DoxyParamCaption})}

Decode a base58-\/encoded string (str) into a byte vector (vch\+Ret). return true if decoding is successful. \mbox{\Hypertarget{base58_8h_ae2dc7ad63e243509e0871ec4a5890678}\label{base58_8h_ae2dc7ad63e243509e0871ec4a5890678}} 
\index{base58.\+h@{base58.\+h}!Decode\+Base58\+Check@{Decode\+Base58\+Check}}
\index{Decode\+Base58\+Check@{Decode\+Base58\+Check}!base58.\+h@{base58.\+h}}
\subsubsection{\texorpdfstring{Decode\+Base58\+Check()}{DecodeBase58Check()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily bool Decode\+Base58\+Check (\begin{DoxyParamCaption}\item[{const char $\ast$}]{psz,  }\item[{std\+::vector$<$ unsigned char $>$ \&}]{vch\+Ret }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Decode a base58-\/encoded string (psz) that includes a checksum into a byte vector (vch\+Ret), return true if decoding is successful \mbox{\Hypertarget{base58_8h_a96597527b13547236b99430e6ac195b3}\label{base58_8h_a96597527b13547236b99430e6ac195b3}} 
\index{base58.\+h@{base58.\+h}!Decode\+Base58\+Check@{Decode\+Base58\+Check}}
\index{Decode\+Base58\+Check@{Decode\+Base58\+Check}!base58.\+h@{base58.\+h}}
\subsubsection{\texorpdfstring{Decode\+Base58\+Check()}{DecodeBase58Check()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily bool Decode\+Base58\+Check (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{str,  }\item[{std\+::vector$<$ unsigned char $>$ \&}]{vch\+Ret }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Decode a base58-\/encoded string (str) that includes a checksum into a byte vector (vch\+Ret), return true if decoding is successful \mbox{\Hypertarget{base58_8h_a8d6f0e9d5df175b4966dcede31dc90ad}\label{base58_8h_a8d6f0e9d5df175b4966dcede31dc90ad}} 
\index{base58.\+h@{base58.\+h}!Encode\+Base58@{Encode\+Base58}}
\index{Encode\+Base58@{Encode\+Base58}!base58.\+h@{base58.\+h}}
\subsubsection{\texorpdfstring{Encode\+Base58()}{EncodeBase58()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily std\+::string Encode\+Base58 (\begin{DoxyParamCaption}\item[{const unsigned char $\ast$}]{pbegin,  }\item[{const unsigned char $\ast$}]{pend }\end{DoxyParamCaption})}

Why base-\/58 instead of standard base-\/64 encoding?
\begin{DoxyItemize}
\item Don\textquotesingle{}t want 0\+O\+Il characters that look the same in some fonts and could be used to create visually identical looking data.
\item A string with non-\/alphanumeric characters is not as easily accepted as input.
\item E-\/mail usually won\textquotesingle{}t line-\/break if there\textquotesingle{}s no punctuation to break at.
\item Double-\/clicking selects the whole string as one word if it\textquotesingle{}s all alphanumeric. Encode a byte sequence as a base58-\/encoded string. pbegin and pend cannot be N\+U\+LL, unless both are. 
\end{DoxyItemize}\mbox{\Hypertarget{base58_8h_ab95cf95fa4e2631017335c2ea73090bc}\label{base58_8h_ab95cf95fa4e2631017335c2ea73090bc}} 
\index{base58.\+h@{base58.\+h}!Encode\+Base58@{Encode\+Base58}}
\index{Encode\+Base58@{Encode\+Base58}!base58.\+h@{base58.\+h}}
\subsubsection{\texorpdfstring{Encode\+Base58()}{EncodeBase58()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily std\+::string Encode\+Base58 (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ unsigned char $>$ \&}]{vch }\end{DoxyParamCaption})}

Encode a byte vector as a base58-\/encoded string \mbox{\Hypertarget{base58_8h_ace9a5807ee51604f33044339f073ec76}\label{base58_8h_ace9a5807ee51604f33044339f073ec76}} 
\index{base58.\+h@{base58.\+h}!Encode\+Base58\+Check@{Encode\+Base58\+Check}}
\index{Encode\+Base58\+Check@{Encode\+Base58\+Check}!base58.\+h@{base58.\+h}}
\subsubsection{\texorpdfstring{Encode\+Base58\+Check()}{EncodeBase58Check()}}
{\footnotesize\ttfamily std\+::string Encode\+Base58\+Check (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ unsigned char $>$ \&}]{vch\+In }\end{DoxyParamCaption})}

Encode a byte vector into a base58-\/encoded string, including checksum 