\hypertarget{class_c_key}{}\section{C\+Key Class Reference}
\label{class_c_key}\index{C\+Key@{C\+Key}}


{\ttfamily \#include $<$key.\+h$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{class_c_key_a8f4ca910c7b7e729a3f2a5c59d060d3d}{C\+Key}} ()
\begin{DoxyCompactList}\small\item\em Construct an invalid private key. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_c_key_afcea34cefd25675f4cf9b03eaa4bb7d9}{C\+Key}} (const \mbox{\hyperlink{class_c_key}{C\+Key}} \&secret)
\begin{DoxyCompactList}\small\item\em Copy constructor. This is necessary because of memlocking. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_c_key_a57d5b254748cef054c40f99c1c339147}{$\sim$\+C\+Key}} ()
\begin{DoxyCompactList}\small\item\em Destructor (again necessary because of memlocking). \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{class_c_key_aaa13d5f08456bba094210c5eeabf64c8}{Set}} (const T pbegin, const T pend, bool f\+Compressed\+In)
\begin{DoxyCompactList}\small\item\em Initialize using begin and end iterators to byte data. \end{DoxyCompactList}\item 
unsigned int \mbox{\hyperlink{class_c_key_a468a9a8cd148ab4a43e7d76bbdc78abe}{size}} () const
\begin{DoxyCompactList}\small\item\em Simple read-\/only vector-\/like interface. \end{DoxyCompactList}\item 
const unsigned char $\ast$ \mbox{\hyperlink{class_c_key_ab8dee0ad9d933304a22284ee40040847}{begin}} () const
\item 
const unsigned char $\ast$ \mbox{\hyperlink{class_c_key_a41c700c4a732672e4b7cc60d811dbf41}{end}} () const
\item 
bool \mbox{\hyperlink{class_c_key_a56e06c48d504a1a65e244e5fc35cdecc}{Is\+Valid}} () const
\begin{DoxyCompactList}\small\item\em Check whether this private key is valid. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_c_key_a96b017433a65335775cf3807d73f85ce}{Is\+Compressed}} () const
\begin{DoxyCompactList}\small\item\em Check whether the public key corresponding to this private key is (to be) compressed. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_c_key_aa62c082c9037565fce02b457cc335e7b}{Set\+Priv\+Key}} (const \mbox{\hyperlink{key_8h_a1da569b8b6e5b3fa1196cc1b877e7f54}{C\+Priv\+Key}} \&vch\+Priv\+Key, bool \mbox{\hyperlink{class_c_key_a9e5f8cac8811466c735d7af6f17a0dfe}{f\+Compressed}})
\begin{DoxyCompactList}\small\item\em Initialize from a C\+Priv\+Key (serialized Open\+S\+SL private key data). \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_c_key_a9d12ed9d297e4286250fd7ea6b59e1a5}{Make\+New\+Key}} (bool \mbox{\hyperlink{class_c_key_a9e5f8cac8811466c735d7af6f17a0dfe}{f\+Compressed}})
\begin{DoxyCompactList}\small\item\em Generate a new private key using a cryptographic P\+R\+NG. \end{DoxyCompactList}\item 
\mbox{\hyperlink{key_8h_a1da569b8b6e5b3fa1196cc1b877e7f54}{C\+Priv\+Key}} \mbox{\hyperlink{class_c_key_a91b6ecf71cc16e0b05ce79ec9276e729}{Get\+Priv\+Key}} () const
\item 
\mbox{\hyperlink{class_c_pub_key}{C\+Pub\+Key}} \mbox{\hyperlink{class_c_key_aa1085c59603a62db6ec776300f250337}{Get\+Pub\+Key}} () const
\item 
bool \mbox{\hyperlink{class_c_key_aa9b184a4a71d3e1a40aab360cf68e86c}{Sign}} (const \mbox{\hyperlink{classuint256}{uint256}} \&hash, std\+::vector$<$ unsigned char $>$ \&vch\+Sig, uint32\+\_\+t test\+\_\+case=0) const
\item 
bool \mbox{\hyperlink{class_c_key_afe77d80889aa68e92e6882e75424cfb8}{Sign\+Compact}} (const \mbox{\hyperlink{classuint256}{uint256}} \&hash, std\+::vector$<$ unsigned char $>$ \&vch\+Sig) const
\item 
bool \mbox{\hyperlink{class_c_key_ae79008cec2eb799a2efd37e010996acf}{Derive}} (\mbox{\hyperlink{class_c_key}{C\+Key}} \&key\+Child, \mbox{\hyperlink{hash_8h_aa201a9867f780a040c7af908e0a85db3}{Chain\+Code}} \&cc\+Child, unsigned int n\+Child, const \mbox{\hyperlink{hash_8h_aa201a9867f780a040c7af908e0a85db3}{Chain\+Code}} \&cc) const
\begin{DoxyCompactList}\small\item\em Derive B\+I\+P32 child key. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_c_key_ac53425b8d0f89067bce781c485101b20}{Verify\+Pub\+Key}} (const \mbox{\hyperlink{class_c_pub_key}{C\+Pub\+Key}} \&vch\+Pub\+Key) const
\item 
bool \mbox{\hyperlink{class_c_key_a141751588f8bfe5f1b6fc27f4e64b63f}{Load}} (\mbox{\hyperlink{key_8h_a1da569b8b6e5b3fa1196cc1b877e7f54}{C\+Priv\+Key}} \&privkey, \mbox{\hyperlink{class_c_pub_key}{C\+Pub\+Key}} \&vch\+Pub\+Key, bool f\+Skip\+Check)
\begin{DoxyCompactList}\small\item\em Load private key and check that public key matches. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static bool \mbox{\hyperlink{class_c_key_a625c363d9adfbd4dda22f3a67a898cf4}{Check\+Signature\+Element}} (const unsigned char $\ast$\mbox{\hyperlink{class_c_key_a07f9e2b043670dfbaa9b7b4e782ed116}{vch}}, int len, bool half)
\begin{DoxyCompactList}\small\item\em Check whether an element of a signature (r or s) is valid. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Private Member Functions}
\begin{DoxyCompactItemize}
\item 
static bool \mbox{\hyperlink{class_c_key_acec869bc75fa8f4d619ab025d367a97c}{Check}} (const unsigned char $\ast$\mbox{\hyperlink{class_c_key_a07f9e2b043670dfbaa9b7b4e782ed116}{vch}})
\begin{DoxyCompactList}\small\item\em Check whether the 32-\/byte array pointed to be vch is valid keydata. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
bool \mbox{\hyperlink{class_c_key_a78cdd7f831519b5167f6c801f49fa977}{f\+Valid}}
\item 
bool \mbox{\hyperlink{class_c_key_a9e5f8cac8811466c735d7af6f17a0dfe}{f\+Compressed}}
\begin{DoxyCompactList}\small\item\em Whether the public key corresponding to this private key is (to be) compressed. \end{DoxyCompactList}\item 
unsigned char \mbox{\hyperlink{class_c_key_a07f9e2b043670dfbaa9b7b4e782ed116}{vch}} \mbox{[}32\mbox{]}
\begin{DoxyCompactList}\small\item\em The actual byte data. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Friends}
\begin{DoxyCompactItemize}
\item 
bool \mbox{\hyperlink{class_c_key_a381efd9184dc467e73e690329c70371d}{operator==}} (const \mbox{\hyperlink{class_c_key}{C\+Key}} \&a, const \mbox{\hyperlink{class_c_key}{C\+Key}} \&b)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
An encapsulated private key. 

\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{class_c_key_a8f4ca910c7b7e729a3f2a5c59d060d3d}\label{class_c_key_a8f4ca910c7b7e729a3f2a5c59d060d3d}} 
\index{C\+Key@{C\+Key}!C\+Key@{C\+Key}}
\index{C\+Key@{C\+Key}!C\+Key@{C\+Key}}
\subsubsection{\texorpdfstring{C\+Key()}{CKey()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily C\+Key\+::\+C\+Key (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Construct an invalid private key. 

\mbox{\Hypertarget{class_c_key_afcea34cefd25675f4cf9b03eaa4bb7d9}\label{class_c_key_afcea34cefd25675f4cf9b03eaa4bb7d9}} 
\index{C\+Key@{C\+Key}!C\+Key@{C\+Key}}
\index{C\+Key@{C\+Key}!C\+Key@{C\+Key}}
\subsubsection{\texorpdfstring{C\+Key()}{CKey()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily C\+Key\+::\+C\+Key (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_c_key}{C\+Key}} \&}]{secret }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Copy constructor. This is necessary because of memlocking. 

\mbox{\Hypertarget{class_c_key_a57d5b254748cef054c40f99c1c339147}\label{class_c_key_a57d5b254748cef054c40f99c1c339147}} 
\index{C\+Key@{C\+Key}!````~C\+Key@{$\sim$\+C\+Key}}
\index{````~C\+Key@{$\sim$\+C\+Key}!C\+Key@{C\+Key}}
\subsubsection{\texorpdfstring{$\sim$\+C\+Key()}{~CKey()}}
{\footnotesize\ttfamily C\+Key\+::$\sim$\+C\+Key (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Destructor (again necessary because of memlocking). 



\subsection{Member Function Documentation}
\mbox{\Hypertarget{class_c_key_ab8dee0ad9d933304a22284ee40040847}\label{class_c_key_ab8dee0ad9d933304a22284ee40040847}} 
\index{C\+Key@{C\+Key}!begin@{begin}}
\index{begin@{begin}!C\+Key@{C\+Key}}
\subsubsection{\texorpdfstring{begin()}{begin()}}
{\footnotesize\ttfamily const unsigned char$\ast$ C\+Key\+::begin (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{class_c_key_acec869bc75fa8f4d619ab025d367a97c}\label{class_c_key_acec869bc75fa8f4d619ab025d367a97c}} 
\index{C\+Key@{C\+Key}!Check@{Check}}
\index{Check@{Check}!C\+Key@{C\+Key}}
\subsubsection{\texorpdfstring{Check()}{Check()}}
{\footnotesize\ttfamily bool C\+Key\+::\+Check (\begin{DoxyParamCaption}\item[{const unsigned char $\ast$}]{vch }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}



Check whether the 32-\/byte array pointed to be vch is valid keydata. 

\mbox{\Hypertarget{class_c_key_a625c363d9adfbd4dda22f3a67a898cf4}\label{class_c_key_a625c363d9adfbd4dda22f3a67a898cf4}} 
\index{C\+Key@{C\+Key}!Check\+Signature\+Element@{Check\+Signature\+Element}}
\index{Check\+Signature\+Element@{Check\+Signature\+Element}!C\+Key@{C\+Key}}
\subsubsection{\texorpdfstring{Check\+Signature\+Element()}{CheckSignatureElement()}}
{\footnotesize\ttfamily static bool C\+Key\+::\+Check\+Signature\+Element (\begin{DoxyParamCaption}\item[{const unsigned char $\ast$}]{vch,  }\item[{int}]{len,  }\item[{bool}]{half }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Check whether an element of a signature (r or s) is valid. 

\mbox{\Hypertarget{class_c_key_ae79008cec2eb799a2efd37e010996acf}\label{class_c_key_ae79008cec2eb799a2efd37e010996acf}} 
\index{C\+Key@{C\+Key}!Derive@{Derive}}
\index{Derive@{Derive}!C\+Key@{C\+Key}}
\subsubsection{\texorpdfstring{Derive()}{Derive()}}
{\footnotesize\ttfamily bool C\+Key\+::\+Derive (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_c_key}{C\+Key}} \&}]{key\+Child,  }\item[{\mbox{\hyperlink{hash_8h_aa201a9867f780a040c7af908e0a85db3}{Chain\+Code}} \&}]{cc\+Child,  }\item[{unsigned int}]{n\+Child,  }\item[{const \mbox{\hyperlink{hash_8h_aa201a9867f780a040c7af908e0a85db3}{Chain\+Code}} \&}]{cc }\end{DoxyParamCaption}) const}



Derive B\+I\+P32 child key. 

\mbox{\Hypertarget{class_c_key_a41c700c4a732672e4b7cc60d811dbf41}\label{class_c_key_a41c700c4a732672e4b7cc60d811dbf41}} 
\index{C\+Key@{C\+Key}!end@{end}}
\index{end@{end}!C\+Key@{C\+Key}}
\subsubsection{\texorpdfstring{end()}{end()}}
{\footnotesize\ttfamily const unsigned char$\ast$ C\+Key\+::end (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{class_c_key_a91b6ecf71cc16e0b05ce79ec9276e729}\label{class_c_key_a91b6ecf71cc16e0b05ce79ec9276e729}} 
\index{C\+Key@{C\+Key}!Get\+Priv\+Key@{Get\+Priv\+Key}}
\index{Get\+Priv\+Key@{Get\+Priv\+Key}!C\+Key@{C\+Key}}
\subsubsection{\texorpdfstring{Get\+Priv\+Key()}{GetPrivKey()}}
{\footnotesize\ttfamily \mbox{\hyperlink{key_8h_a1da569b8b6e5b3fa1196cc1b877e7f54}{C\+Priv\+Key}} C\+Key\+::\+Get\+Priv\+Key (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}

Convert the private key to a C\+Priv\+Key (serialized Open\+S\+SL private key data). This is expensive. \mbox{\Hypertarget{class_c_key_aa1085c59603a62db6ec776300f250337}\label{class_c_key_aa1085c59603a62db6ec776300f250337}} 
\index{C\+Key@{C\+Key}!Get\+Pub\+Key@{Get\+Pub\+Key}}
\index{Get\+Pub\+Key@{Get\+Pub\+Key}!C\+Key@{C\+Key}}
\subsubsection{\texorpdfstring{Get\+Pub\+Key()}{GetPubKey()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_c_pub_key}{C\+Pub\+Key}} C\+Key\+::\+Get\+Pub\+Key (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}

Compute the public key from a private key. This is expensive. \mbox{\Hypertarget{class_c_key_a96b017433a65335775cf3807d73f85ce}\label{class_c_key_a96b017433a65335775cf3807d73f85ce}} 
\index{C\+Key@{C\+Key}!Is\+Compressed@{Is\+Compressed}}
\index{Is\+Compressed@{Is\+Compressed}!C\+Key@{C\+Key}}
\subsubsection{\texorpdfstring{Is\+Compressed()}{IsCompressed()}}
{\footnotesize\ttfamily bool C\+Key\+::\+Is\+Compressed (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Check whether the public key corresponding to this private key is (to be) compressed. 

\mbox{\Hypertarget{class_c_key_a56e06c48d504a1a65e244e5fc35cdecc}\label{class_c_key_a56e06c48d504a1a65e244e5fc35cdecc}} 
\index{C\+Key@{C\+Key}!Is\+Valid@{Is\+Valid}}
\index{Is\+Valid@{Is\+Valid}!C\+Key@{C\+Key}}
\subsubsection{\texorpdfstring{Is\+Valid()}{IsValid()}}
{\footnotesize\ttfamily bool C\+Key\+::\+Is\+Valid (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Check whether this private key is valid. 

\mbox{\Hypertarget{class_c_key_a141751588f8bfe5f1b6fc27f4e64b63f}\label{class_c_key_a141751588f8bfe5f1b6fc27f4e64b63f}} 
\index{C\+Key@{C\+Key}!Load@{Load}}
\index{Load@{Load}!C\+Key@{C\+Key}}
\subsubsection{\texorpdfstring{Load()}{Load()}}
{\footnotesize\ttfamily bool C\+Key\+::\+Load (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{key_8h_a1da569b8b6e5b3fa1196cc1b877e7f54}{C\+Priv\+Key}} \&}]{privkey,  }\item[{\mbox{\hyperlink{class_c_pub_key}{C\+Pub\+Key}} \&}]{vch\+Pub\+Key,  }\item[{bool}]{f\+Skip\+Check = {\ttfamily false} }\end{DoxyParamCaption})}



Load private key and check that public key matches. 

\mbox{\Hypertarget{class_c_key_a9d12ed9d297e4286250fd7ea6b59e1a5}\label{class_c_key_a9d12ed9d297e4286250fd7ea6b59e1a5}} 
\index{C\+Key@{C\+Key}!Make\+New\+Key@{Make\+New\+Key}}
\index{Make\+New\+Key@{Make\+New\+Key}!C\+Key@{C\+Key}}
\subsubsection{\texorpdfstring{Make\+New\+Key()}{MakeNewKey()}}
{\footnotesize\ttfamily void C\+Key\+::\+Make\+New\+Key (\begin{DoxyParamCaption}\item[{bool}]{f\+Compressed }\end{DoxyParamCaption})}



Generate a new private key using a cryptographic P\+R\+NG. 

\mbox{\Hypertarget{class_c_key_aaa13d5f08456bba094210c5eeabf64c8}\label{class_c_key_aaa13d5f08456bba094210c5eeabf64c8}} 
\index{C\+Key@{C\+Key}!Set@{Set}}
\index{Set@{Set}!C\+Key@{C\+Key}}
\subsubsection{\texorpdfstring{Set()}{Set()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void C\+Key\+::\+Set (\begin{DoxyParamCaption}\item[{const T}]{pbegin,  }\item[{const T}]{pend,  }\item[{bool}]{f\+Compressed\+In }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Initialize using begin and end iterators to byte data. 

\mbox{\Hypertarget{class_c_key_aa62c082c9037565fce02b457cc335e7b}\label{class_c_key_aa62c082c9037565fce02b457cc335e7b}} 
\index{C\+Key@{C\+Key}!Set\+Priv\+Key@{Set\+Priv\+Key}}
\index{Set\+Priv\+Key@{Set\+Priv\+Key}!C\+Key@{C\+Key}}
\subsubsection{\texorpdfstring{Set\+Priv\+Key()}{SetPrivKey()}}
{\footnotesize\ttfamily bool C\+Key\+::\+Set\+Priv\+Key (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{key_8h_a1da569b8b6e5b3fa1196cc1b877e7f54}{C\+Priv\+Key}} \&}]{vch\+Priv\+Key,  }\item[{bool}]{f\+Compressed }\end{DoxyParamCaption})}



Initialize from a C\+Priv\+Key (serialized Open\+S\+SL private key data). 

\mbox{\Hypertarget{class_c_key_aa9b184a4a71d3e1a40aab360cf68e86c}\label{class_c_key_aa9b184a4a71d3e1a40aab360cf68e86c}} 
\index{C\+Key@{C\+Key}!Sign@{Sign}}
\index{Sign@{Sign}!C\+Key@{C\+Key}}
\subsubsection{\texorpdfstring{Sign()}{Sign()}}
{\footnotesize\ttfamily bool C\+Key\+::\+Sign (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classuint256}{uint256}} \&}]{hash,  }\item[{std\+::vector$<$ unsigned char $>$ \&}]{vch\+Sig,  }\item[{uint32\+\_\+t}]{test\+\_\+case = {\ttfamily 0} }\end{DoxyParamCaption}) const}

Create a D\+E\+R-\/serialized signature. The test\+\_\+case parameter tweaks the deterministic nonce. \mbox{\Hypertarget{class_c_key_afe77d80889aa68e92e6882e75424cfb8}\label{class_c_key_afe77d80889aa68e92e6882e75424cfb8}} 
\index{C\+Key@{C\+Key}!Sign\+Compact@{Sign\+Compact}}
\index{Sign\+Compact@{Sign\+Compact}!C\+Key@{C\+Key}}
\subsubsection{\texorpdfstring{Sign\+Compact()}{SignCompact()}}
{\footnotesize\ttfamily bool C\+Key\+::\+Sign\+Compact (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classuint256}{uint256}} \&}]{hash,  }\item[{std\+::vector$<$ unsigned char $>$ \&}]{vch\+Sig }\end{DoxyParamCaption}) const}

Create a compact signature (65 bytes), which allows reconstructing the used public key. The format is one header byte, followed by two times 32 bytes for the serialized r and s values. The header byte\+: 0x1B = first key with even y, 0x1C = first key with odd y, 0x1D = second key with even y, 0x1E = second key with odd y, add 0x04 for compressed keys. \mbox{\Hypertarget{class_c_key_a468a9a8cd148ab4a43e7d76bbdc78abe}\label{class_c_key_a468a9a8cd148ab4a43e7d76bbdc78abe}} 
\index{C\+Key@{C\+Key}!size@{size}}
\index{size@{size}!C\+Key@{C\+Key}}
\subsubsection{\texorpdfstring{size()}{size()}}
{\footnotesize\ttfamily unsigned int C\+Key\+::size (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Simple read-\/only vector-\/like interface. 

\mbox{\Hypertarget{class_c_key_ac53425b8d0f89067bce781c485101b20}\label{class_c_key_ac53425b8d0f89067bce781c485101b20}} 
\index{C\+Key@{C\+Key}!Verify\+Pub\+Key@{Verify\+Pub\+Key}}
\index{Verify\+Pub\+Key@{Verify\+Pub\+Key}!C\+Key@{C\+Key}}
\subsubsection{\texorpdfstring{Verify\+Pub\+Key()}{VerifyPubKey()}}
{\footnotesize\ttfamily bool C\+Key\+::\+Verify\+Pub\+Key (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_c_pub_key}{C\+Pub\+Key}} \&}]{vch\+Pub\+Key }\end{DoxyParamCaption}) const}

Verify thoroughly whether a private key and a public key match. This is done using a different mechanism than just regenerating it. 

\subsection{Friends And Related Function Documentation}
\mbox{\Hypertarget{class_c_key_a381efd9184dc467e73e690329c70371d}\label{class_c_key_a381efd9184dc467e73e690329c70371d}} 
\index{C\+Key@{C\+Key}!operator==@{operator==}}
\index{operator==@{operator==}!C\+Key@{C\+Key}}
\subsubsection{\texorpdfstring{operator==}{operator==}}
{\footnotesize\ttfamily bool operator== (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_c_key}{C\+Key}} \&}]{a,  }\item[{const \mbox{\hyperlink{class_c_key}{C\+Key}} \&}]{b }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [friend]}}



\subsection{Member Data Documentation}
\mbox{\Hypertarget{class_c_key_a9e5f8cac8811466c735d7af6f17a0dfe}\label{class_c_key_a9e5f8cac8811466c735d7af6f17a0dfe}} 
\index{C\+Key@{C\+Key}!f\+Compressed@{f\+Compressed}}
\index{f\+Compressed@{f\+Compressed}!C\+Key@{C\+Key}}
\subsubsection{\texorpdfstring{f\+Compressed}{fCompressed}}
{\footnotesize\ttfamily bool C\+Key\+::f\+Compressed\hspace{0.3cm}{\ttfamily [private]}}



Whether the public key corresponding to this private key is (to be) compressed. 

\mbox{\Hypertarget{class_c_key_a78cdd7f831519b5167f6c801f49fa977}\label{class_c_key_a78cdd7f831519b5167f6c801f49fa977}} 
\index{C\+Key@{C\+Key}!f\+Valid@{f\+Valid}}
\index{f\+Valid@{f\+Valid}!C\+Key@{C\+Key}}
\subsubsection{\texorpdfstring{f\+Valid}{fValid}}
{\footnotesize\ttfamily bool C\+Key\+::f\+Valid\hspace{0.3cm}{\ttfamily [private]}}

Whether this private key is valid. We check for correctness when modifying the key data, so f\+Valid should always correspond to the actual state. \mbox{\Hypertarget{class_c_key_a07f9e2b043670dfbaa9b7b4e782ed116}\label{class_c_key_a07f9e2b043670dfbaa9b7b4e782ed116}} 
\index{C\+Key@{C\+Key}!vch@{vch}}
\index{vch@{vch}!C\+Key@{C\+Key}}
\subsubsection{\texorpdfstring{vch}{vch}}
{\footnotesize\ttfamily unsigned char C\+Key\+::vch\mbox{[}32\mbox{]}\hspace{0.3cm}{\ttfamily [private]}}



The actual byte data. 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
/\+Users/christopherarguello/\+Developer/anon/src/\mbox{\hyperlink{key_8h}{key.\+h}}\item 
/\+Users/christopherarguello/\+Developer/anon/src/\mbox{\hyperlink{key_8cpp}{key.\+cpp}}\end{DoxyCompactItemize}
